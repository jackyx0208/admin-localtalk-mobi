{"ast":null,"code":"/**\n * @param {string} value\n * @returns {RegExp}\n * */\n\n/**\n * @param {RegExp | string } re\n * @returns {string}\n */\nfunction source(re) {\n  if (!re) return null;\n  if (typeof re === \"string\") return re;\n  return re.source;\n}\n/**\n * @param {...(RegExp | string) } args\n * @returns {string}\n */\n\n\nfunction concat() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  var joined = args.map(function (x) {\n    return source(x);\n  }).join(\"\");\n  return joined;\n}\n/*\nLanguage: Elixir\nAuthor: Josh Adams <josh@isotope11.com>\nDescription: language definition for Elixir source code files (.ex and .exs).  Based on ruby language support.\nCategory: functional\nWebsite: https://elixir-lang.org\n*/\n\n/** @type LanguageFn */\n\n\nfunction elixir(hljs) {\n  var ELIXIR_IDENT_RE = '[a-zA-Z_][a-zA-Z0-9_.]*(!|\\\\?)?';\n  var ELIXIR_METHOD_RE = '[a-zA-Z_]\\\\w*[!?=]?|[-+~]@|<<|>>|=~|===?|<=>|[<>]=?|\\\\*\\\\*|[-/+%^&*~`|]|\\\\[\\\\]=?';\n  var KEYWORDS = [\"after\", \"alias\", \"and\", \"case\", \"catch\", \"cond\", \"defstruct\", \"do\", \"else\", \"end\", \"fn\", \"for\", \"if\", \"import\", \"in\", \"not\", \"or\", \"quote\", \"raise\", \"receive\", \"require\", \"reraise\", \"rescue\", \"try\", \"unless\", \"unquote\", \"unquote_splicing\", \"use\", \"when\", \"with|0\"];\n  var LITERALS = [\"false\", \"nil\", \"true\"];\n  var KWS = {\n    $pattern: ELIXIR_IDENT_RE,\n    keyword: KEYWORDS,\n    literal: LITERALS\n  };\n  var SUBST = {\n    className: 'subst',\n    begin: /#\\{/,\n    end: /\\}/,\n    keywords: KWS\n  };\n  var NUMBER = {\n    className: 'number',\n    begin: '(\\\\b0o[0-7_]+)|(\\\\b0b[01_]+)|(\\\\b0x[0-9a-fA-F_]+)|(-?\\\\b[0-9][0-9_]*(\\\\.[0-9_]+([eE][-+]?[0-9]+)?)?)',\n    relevance: 0\n  }; // TODO: could be tightened\n  // https://elixir-lang.readthedocs.io/en/latest/intro/18.html\n  // but you also need to include closing delemeters in the escape list per\n  // individual sigil mode from what I can tell,\n  // ie: \\} might or might not be an escape depending on the sigil used\n\n  var ESCAPES_RE = /\\\\[\\s\\S]/; // const ESCAPES_RE = /\\\\[\"'\\\\abdefnrstv0]/;\n\n  var BACKSLASH_ESCAPE = {\n    match: ESCAPES_RE,\n    scope: \"char.escape\",\n    relevance: 0\n  };\n  var SIGIL_DELIMITERS = '[/|([{<\"\\']';\n  var SIGIL_DELIMITER_MODES = [{\n    begin: /\"/,\n    end: /\"/\n  }, {\n    begin: /'/,\n    end: /'/\n  }, {\n    begin: /\\//,\n    end: /\\//\n  }, {\n    begin: /\\|/,\n    end: /\\|/\n  }, {\n    begin: /\\(/,\n    end: /\\)/\n  }, {\n    begin: /\\[/,\n    end: /\\]/\n  }, {\n    begin: /\\{/,\n    end: /\\}/\n  }, {\n    begin: /</,\n    end: />/\n  }];\n\n  var escapeSigilEnd = function escapeSigilEnd(end) {\n    return {\n      scope: \"char.escape\",\n      begin: concat(/\\\\/, end),\n      relevance: 0\n    };\n  };\n\n  var LOWERCASE_SIGIL = {\n    className: 'string',\n    begin: '~[a-z]' + '(?=' + SIGIL_DELIMITERS + ')',\n    contains: SIGIL_DELIMITER_MODES.map(function (x) {\n      return hljs.inherit(x, {\n        contains: [escapeSigilEnd(x.end), BACKSLASH_ESCAPE, SUBST]\n      });\n    })\n  };\n  var UPCASE_SIGIL = {\n    className: 'string',\n    begin: '~[A-Z]' + '(?=' + SIGIL_DELIMITERS + ')',\n    contains: SIGIL_DELIMITER_MODES.map(function (x) {\n      return hljs.inherit(x, {\n        contains: [escapeSigilEnd(x.end)]\n      });\n    })\n  };\n  var REGEX_SIGIL = {\n    className: 'regex',\n    variants: [{\n      begin: '~r' + '(?=' + SIGIL_DELIMITERS + ')',\n      contains: SIGIL_DELIMITER_MODES.map(function (x) {\n        return hljs.inherit(x, {\n          end: concat(x.end, /[uismxfU]{0,7}/),\n          contains: [escapeSigilEnd(x.end), BACKSLASH_ESCAPE, SUBST]\n        });\n      })\n    }, {\n      begin: '~R' + '(?=' + SIGIL_DELIMITERS + ')',\n      contains: SIGIL_DELIMITER_MODES.map(function (x) {\n        return hljs.inherit(x, {\n          end: concat(x.end, /[uismxfU]{0,7}/),\n          contains: [escapeSigilEnd(x.end)]\n        });\n      })\n    }]\n  };\n  var STRING = {\n    className: 'string',\n    contains: [hljs.BACKSLASH_ESCAPE, SUBST],\n    variants: [{\n      begin: /\"\"\"/,\n      end: /\"\"\"/\n    }, {\n      begin: /'''/,\n      end: /'''/\n    }, {\n      begin: /~S\"\"\"/,\n      end: /\"\"\"/,\n      contains: [] // override default\n\n    }, {\n      begin: /~S\"/,\n      end: /\"/,\n      contains: [] // override default\n\n    }, {\n      begin: /~S'''/,\n      end: /'''/,\n      contains: [] // override default\n\n    }, {\n      begin: /~S'/,\n      end: /'/,\n      contains: [] // override default\n\n    }, {\n      begin: /'/,\n      end: /'/\n    }, {\n      begin: /\"/,\n      end: /\"/\n    }]\n  };\n  var FUNCTION = {\n    className: 'function',\n    beginKeywords: 'def defp defmacro defmacrop',\n    end: /\\B\\b/,\n    // the mode is ended by the title\n    contains: [hljs.inherit(hljs.TITLE_MODE, {\n      begin: ELIXIR_IDENT_RE,\n      endsParent: true\n    })]\n  };\n  var CLASS = hljs.inherit(FUNCTION, {\n    className: 'class',\n    beginKeywords: 'defimpl defmodule defprotocol defrecord',\n    end: /\\bdo\\b|$|;/\n  });\n  var ELIXIR_DEFAULT_CONTAINS = [STRING, REGEX_SIGIL, UPCASE_SIGIL, LOWERCASE_SIGIL, hljs.HASH_COMMENT_MODE, CLASS, FUNCTION, {\n    begin: '::'\n  }, {\n    className: 'symbol',\n    begin: ':(?![\\\\s:])',\n    contains: [STRING, {\n      begin: ELIXIR_METHOD_RE\n    }],\n    relevance: 0\n  }, {\n    className: 'symbol',\n    begin: ELIXIR_IDENT_RE + ':(?!:)',\n    relevance: 0\n  }, NUMBER, {\n    className: 'variable',\n    begin: '(\\\\$\\\\W)|((\\\\$|@@?)(\\\\w+))'\n  }, {\n    begin: '->'\n  }];\n  SUBST.contains = ELIXIR_DEFAULT_CONTAINS;\n  return {\n    name: 'Elixir',\n    aliases: ['ex', 'exs'],\n    keywords: KWS,\n    contains: ELIXIR_DEFAULT_CONTAINS\n  };\n}\n\nmodule.exports = elixir;","map":{"version":3,"sources":["E:/projects/localtalk.mobi/mobilechat-adminpanel/node_modules/highlight.js/lib/languages/elixir.js"],"names":["source","re","concat","args","joined","map","x","join","elixir","hljs","ELIXIR_IDENT_RE","ELIXIR_METHOD_RE","KEYWORDS","LITERALS","KWS","$pattern","keyword","literal","SUBST","className","begin","end","keywords","NUMBER","relevance","ESCAPES_RE","BACKSLASH_ESCAPE","match","scope","SIGIL_DELIMITERS","SIGIL_DELIMITER_MODES","escapeSigilEnd","LOWERCASE_SIGIL","contains","inherit","UPCASE_SIGIL","REGEX_SIGIL","variants","STRING","FUNCTION","beginKeywords","TITLE_MODE","endsParent","CLASS","ELIXIR_DEFAULT_CONTAINS","HASH_COMMENT_MODE","name","aliases","module","exports"],"mappings":"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","sourcesContent":["/**\n * @param {string} value\n * @returns {RegExp}\n * */\n\n/**\n * @param {RegExp | string } re\n * @returns {string}\n */\nfunction source(re) {\n  if (!re) return null;\n  if (typeof re === \"string\") return re;\n\n  return re.source;\n}\n\n/**\n * @param {...(RegExp | string) } args\n * @returns {string}\n */\nfunction concat(...args) {\n  const joined = args.map((x) => source(x)).join(\"\");\n  return joined;\n}\n\n/*\nLanguage: Elixir\nAuthor: Josh Adams <josh@isotope11.com>\nDescription: language definition for Elixir source code files (.ex and .exs).  Based on ruby language support.\nCategory: functional\nWebsite: https://elixir-lang.org\n*/\n\n/** @type LanguageFn */\nfunction elixir(hljs) {\n  const ELIXIR_IDENT_RE = '[a-zA-Z_][a-zA-Z0-9_.]*(!|\\\\?)?';\n  const ELIXIR_METHOD_RE = '[a-zA-Z_]\\\\w*[!?=]?|[-+~]@|<<|>>|=~|===?|<=>|[<>]=?|\\\\*\\\\*|[-/+%^&*~`|]|\\\\[\\\\]=?';\n  const KEYWORDS = [\n    \"after\",\n    \"alias\",\n    \"and\",\n    \"case\",\n    \"catch\",\n    \"cond\",\n    \"defstruct\",\n    \"do\",\n    \"else\",\n    \"end\",\n    \"fn\",\n    \"for\",\n    \"if\",\n    \"import\",\n    \"in\",\n    \"not\",\n    \"or\",\n    \"quote\",\n    \"raise\",\n    \"receive\",\n    \"require\",\n    \"reraise\",\n    \"rescue\",\n    \"try\",\n    \"unless\",\n    \"unquote\",\n    \"unquote_splicing\",\n    \"use\",\n    \"when\",\n    \"with|0\"\n  ];\n  const LITERALS = [\n    \"false\",\n    \"nil\",\n    \"true\"\n  ];\n  const KWS = {\n    $pattern: ELIXIR_IDENT_RE,\n    keyword: KEYWORDS,\n    literal: LITERALS\n  };\n  const SUBST = {\n    className: 'subst',\n    begin: /#\\{/,\n    end: /\\}/,\n    keywords: KWS\n  };\n  const NUMBER = {\n    className: 'number',\n    begin: '(\\\\b0o[0-7_]+)|(\\\\b0b[01_]+)|(\\\\b0x[0-9a-fA-F_]+)|(-?\\\\b[0-9][0-9_]*(\\\\.[0-9_]+([eE][-+]?[0-9]+)?)?)',\n    relevance: 0\n  };\n  // TODO: could be tightened\n  // https://elixir-lang.readthedocs.io/en/latest/intro/18.html\n  // but you also need to include closing delemeters in the escape list per\n  // individual sigil mode from what I can tell,\n  // ie: \\} might or might not be an escape depending on the sigil used\n  const ESCAPES_RE = /\\\\[\\s\\S]/;\n  // const ESCAPES_RE = /\\\\[\"'\\\\abdefnrstv0]/;\n  const BACKSLASH_ESCAPE = {\n    match: ESCAPES_RE,\n    scope: \"char.escape\",\n    relevance: 0\n  };\n  const SIGIL_DELIMITERS = '[/|([{<\"\\']';\n  const SIGIL_DELIMITER_MODES = [\n    {\n      begin: /\"/,\n      end: /\"/\n    },\n    {\n      begin: /'/,\n      end: /'/\n    },\n    {\n      begin: /\\//,\n      end: /\\//\n    },\n    {\n      begin: /\\|/,\n      end: /\\|/\n    },\n    {\n      begin: /\\(/,\n      end: /\\)/\n    },\n    {\n      begin: /\\[/,\n      end: /\\]/\n    },\n    {\n      begin: /\\{/,\n      end: /\\}/\n    },\n    {\n      begin: /</,\n      end: />/\n    }\n  ];\n  const escapeSigilEnd = (end) => {\n    return {\n      scope: \"char.escape\",\n      begin: concat(/\\\\/, end),\n      relevance: 0\n    };\n  };\n  const LOWERCASE_SIGIL = {\n    className: 'string',\n    begin: '~[a-z]' + '(?=' + SIGIL_DELIMITERS + ')',\n    contains: SIGIL_DELIMITER_MODES.map(x => hljs.inherit(x,\n      {\n        contains: [\n          escapeSigilEnd(x.end),\n          BACKSLASH_ESCAPE,\n          SUBST\n        ]\n      }\n    ))\n  };\n\n  const UPCASE_SIGIL = {\n    className: 'string',\n    begin: '~[A-Z]' + '(?=' + SIGIL_DELIMITERS + ')',\n    contains: SIGIL_DELIMITER_MODES.map(x => hljs.inherit(x,\n      {\n        contains: [ escapeSigilEnd(x.end) ]\n      }\n    ))\n  };\n\n  const REGEX_SIGIL = {\n    className: 'regex',\n    variants: [\n      {\n        begin: '~r' + '(?=' + SIGIL_DELIMITERS + ')',\n        contains: SIGIL_DELIMITER_MODES.map(x => hljs.inherit(x,\n          {\n            end: concat(x.end, /[uismxfU]{0,7}/),\n            contains: [\n              escapeSigilEnd(x.end),\n              BACKSLASH_ESCAPE,\n              SUBST\n            ]\n          }\n        ))\n      },\n      {\n        begin: '~R' + '(?=' + SIGIL_DELIMITERS + ')',\n        contains: SIGIL_DELIMITER_MODES.map(x => hljs.inherit(x,\n          {\n            end: concat(x.end, /[uismxfU]{0,7}/),\n            contains: [ escapeSigilEnd(x.end) ]\n          })\n        )\n      }\n    ]\n  };\n\n  const STRING = {\n    className: 'string',\n    contains: [\n      hljs.BACKSLASH_ESCAPE,\n      SUBST\n    ],\n    variants: [\n      {\n        begin: /\"\"\"/,\n        end: /\"\"\"/\n      },\n      {\n        begin: /'''/,\n        end: /'''/\n      },\n      {\n        begin: /~S\"\"\"/,\n        end: /\"\"\"/,\n        contains: [] // override default\n      },\n      {\n        begin: /~S\"/,\n        end: /\"/,\n        contains: [] // override default\n      },\n      {\n        begin: /~S'''/,\n        end: /'''/,\n        contains: [] // override default\n      },\n      {\n        begin: /~S'/,\n        end: /'/,\n        contains: [] // override default\n      },\n      {\n        begin: /'/,\n        end: /'/\n      },\n      {\n        begin: /\"/,\n        end: /\"/\n      }\n    ]\n  };\n  const FUNCTION = {\n    className: 'function',\n    beginKeywords: 'def defp defmacro defmacrop',\n    end: /\\B\\b/, // the mode is ended by the title\n    contains: [\n      hljs.inherit(hljs.TITLE_MODE, {\n        begin: ELIXIR_IDENT_RE,\n        endsParent: true\n      })\n    ]\n  };\n  const CLASS = hljs.inherit(FUNCTION, {\n    className: 'class',\n    beginKeywords: 'defimpl defmodule defprotocol defrecord',\n    end: /\\bdo\\b|$|;/\n  });\n  const ELIXIR_DEFAULT_CONTAINS = [\n    STRING,\n    REGEX_SIGIL,\n    UPCASE_SIGIL,\n    LOWERCASE_SIGIL,\n    hljs.HASH_COMMENT_MODE,\n    CLASS,\n    FUNCTION,\n    {\n      begin: '::'\n    },\n    {\n      className: 'symbol',\n      begin: ':(?![\\\\s:])',\n      contains: [\n        STRING,\n        {\n          begin: ELIXIR_METHOD_RE\n        }\n      ],\n      relevance: 0\n    },\n    {\n      className: 'symbol',\n      begin: ELIXIR_IDENT_RE + ':(?!:)',\n      relevance: 0\n    },\n    NUMBER,\n    {\n      className: 'variable',\n      begin: '(\\\\$\\\\W)|((\\\\$|@@?)(\\\\w+))'\n    },\n    {\n      begin: '->'\n    }\n  ];\n  SUBST.contains = ELIXIR_DEFAULT_CONTAINS;\n\n  return {\n    name: 'Elixir',\n    aliases: ['ex', 'exs'],\n    keywords: KWS,\n    contains: ELIXIR_DEFAULT_CONTAINS\n  };\n}\n\nmodule.exports = elixir;\n"]},"metadata":{},"sourceType":"script"}