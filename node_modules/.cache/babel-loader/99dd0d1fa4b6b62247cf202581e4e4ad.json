{"ast":null,"code":"import { v4 as uuidv4 } from 'uuid';\nimport { createSlice } from '@reduxjs/toolkit'; // utils\n\nimport axios from '../../utils/axios'; // ----------------------------------------------------------------------\n\nfunction objFromArray(array, key = '_id') {\n  return array.reduce((accumulator, current) => {\n    accumulator[current[key]] = current;\n    return accumulator;\n  }, {});\n}\n\nconst initialState = {\n  isLoading: false,\n  error: false,\n  contacts: {\n    byId: {},\n    allIds: []\n  },\n  conversations: {\n    byId: {},\n    allIds: []\n  },\n  activeConversationId: null,\n  participants: [],\n  recipients: []\n};\nconst slice = createSlice({\n  name: 'privatechat',\n  initialState,\n  reducers: {\n    // START LOADING\n    startLoading(state) {\n      state.isLoading = true;\n    },\n\n    // HAS ERROR\n    hasError(state, action) {\n      state.isLoading = false;\n      state.error = action.payload;\n    },\n\n    // GET CONTACT SSUCCESS\n    getContactsSuccess(state, action) {\n      const contacts = action.payload;\n      state.contacts.byId = objFromArray(contacts);\n      state.contacts.allIds = Object.keys(state.contacts.byId);\n    },\n\n    // GET CONVERSATIONS\n    getConversationsSuccess(state, action) {\n      const conversations = action.payload;\n      state.conversations.byId = objFromArray(conversations);\n      state.conversations.allIds = Object.keys(state.conversations.byId);\n    },\n\n    // GET CONVERSATION\n    getConversationSuccess(state, action) {\n      const conversation = action.payload;\n\n      if (conversation) {\n        state.conversations.byId[conversation._id] = conversation;\n\n        if (!state.conversations.allIds.includes(conversation._id)) {\n          state.conversations.allIds.push(conversation._id);\n        }\n      }\n    },\n\n    // ON SEND MESSAGE\n    onSendMessage(state, action) {\n      const conversation = action.payload;\n      const {\n        conversationId,\n        messageId,\n        message,\n        imgs,\n        senderId,\n        senderName,\n        receiverId,\n        messageType\n      } = conversation;\n      const newMessage = {\n        sender_id: senderId,\n        sender_name: senderName,\n        _id: messageId,\n        chat_id: conversationId,\n        message,\n        receiver_id: receiverId,\n        message_type: messageType,\n        imgs,\n        createdAt: Date.now()\n      };\n      state.conversations.byId[conversationId].messages.push(newMessage);\n    },\n\n    markConversationAsReadSuccess(state, action) {\n      const {\n        conversationId\n      } = action.payload;\n      const conversation = state.conversations.byId[conversationId];\n\n      if (conversation) {\n        conversation.lastMessage.unread_count = 0;\n      }\n    },\n\n    // GET PARTICIPANTS\n    getParticipantsSuccess(state, action) {\n      const participants = action.payload;\n      state.participants = participants;\n    },\n\n    // RESET ACTIVE CONVERSATION\n    resetActiveConversation(state) {\n      state.activeConversationId = null;\n    },\n\n    getActiveConversationIdSuccess(state, action) {\n      const activeConversationId = action.payload;\n      state.activeConversationId = activeConversationId;\n    },\n\n    addRecipients(state, action) {\n      const recipients = action.payload;\n      state.recipients = recipients;\n    }\n\n  }\n}); // Reducer\n\nexport default slice.reducer; // Actions\n\nexport const {\n  addRecipients,\n  onSendMessage,\n  resetActiveConversation\n} = slice.actions; // ---------------------------------------------------------------------\n// ON SEND MESSAGE\n\nexport function onConnectChat(userOne, userTwo, lastMessage) {\n  return async dispatch => {\n    dispatch(slice.actions.startLoading());\n\n    try {\n      const response = await axios.post('/conversions/create', {\n        user_one: userOne,\n        user_two: userTwo,\n        lastMessage\n      });\n      const responseData = response.data;\n\n      if (responseData.error) {\n        dispatch(slice.actions.hasError(response.data));\n      } else {\n        if (responseData.new) {\n          const newMessage = await axios.post('/message/send', {\n            messageId: uuidv4(),\n            message: lastMessage,\n            senderId: userOne,\n            receiverId: userTwo,\n            chatId: responseData.data._id,\n            messageType: 0,\n            imgs: []\n          });\n        }\n\n        dispatch(slice.actions.getActiveConversationIdSuccess(responseData.data._id));\n      }\n    } catch (error) {\n      dispatch(slice.actions.hasError(error));\n    }\n  };\n} // ----------------------------------------------------------------------\n\nexport function getContacts() {\n  return async dispatch => {\n    dispatch(slice.actions.startLoading());\n\n    try {\n      const response = await axios.get('/conversions/contacts');\n      dispatch(slice.actions.getContactsSuccess(response.data.contacts));\n    } catch (error) {\n      dispatch(slice.actions.hasError(error));\n    }\n  };\n} // ----------------------------------------------------------------------\n\nexport function getConversations() {\n  return async dispatch => {\n    dispatch(slice.actions.startLoading());\n\n    try {\n      const response = await axios.post('/conversions/conversations');\n      dispatch(slice.actions.getConversationsSuccess(response.data.conversations));\n    } catch (error) {\n      dispatch(slice.actions.hasError(error));\n    }\n  };\n} // ----------------------------------------------------------------------\n\nexport function getConversation(chatId) {\n  return async dispatch => {\n    dispatch(slice.actions.startLoading());\n\n    try {\n      const response = await axios.post('/conversions/conversation', {\n        chat_id: chatId\n      });\n      dispatch(slice.actions.getConversationSuccess(response.data.conversation));\n    } catch (error) {\n      dispatch(slice.actions.hasError(error));\n    }\n  };\n} // ----------------------------------------------------------------------\n\nexport function markConversationAsRead(conversationId) {\n  return async dispatch => {\n    dispatch(slice.actions.startLoading());\n\n    try {\n      await axios.get('/chat/conversation/mark-as-seen', {\n        params: {\n          conversationId\n        }\n      });\n      dispatch(slice.actions.markConversationAsReadSuccess({\n        conversationId\n      }));\n    } catch (error) {\n      dispatch(slice.actions.hasError(error));\n    }\n  };\n} // ----------------------------------------------------------------------\n\nexport function getParticipants(conversationKey) {\n  return async dispatch => {\n    dispatch(slice.actions.startLoading());\n\n    try {\n      const response = await axios.get('/chat/participants', {\n        params: {\n          conversationKey\n        }\n      });\n      dispatch(slice.actions.getParticipantsSuccess(response.data.participants));\n    } catch (error) {\n      dispatch(slice.actions.hasError(error));\n    }\n  };\n}","map":{"version":3,"sources":["E:/projects/localtalk.mobi(back)/pro/toptalk-adminpanel/src/redux/slices/privatechat.js"],"names":["v4","uuidv4","createSlice","axios","objFromArray","array","key","reduce","accumulator","current","initialState","isLoading","error","contacts","byId","allIds","conversations","activeConversationId","participants","recipients","slice","name","reducers","startLoading","state","hasError","action","payload","getContactsSuccess","Object","keys","getConversationsSuccess","getConversationSuccess","conversation","_id","includes","push","onSendMessage","conversationId","messageId","message","imgs","senderId","senderName","receiverId","messageType","newMessage","sender_id","sender_name","chat_id","receiver_id","message_type","createdAt","Date","now","messages","markConversationAsReadSuccess","lastMessage","unread_count","getParticipantsSuccess","resetActiveConversation","getActiveConversationIdSuccess","addRecipients","reducer","actions","onConnectChat","userOne","userTwo","dispatch","response","post","user_one","user_two","responseData","data","new","chatId","getContacts","get","getConversations","getConversation","markConversationAsRead","params","getParticipants","conversationKey"],"mappings":"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","sourcesContent":["import { v4 as uuidv4 } from 'uuid';\r\nimport { createSlice } from '@reduxjs/toolkit';\r\n// utils\r\nimport axios from '../../utils/axios';\r\n\r\n// ----------------------------------------------------------------------\r\n\r\nfunction objFromArray(array, key = '_id') {\r\n  return array.reduce((accumulator, current) => {\r\n    accumulator[current[key]] = current;\r\n    return accumulator;\r\n  }, {});\r\n}\r\n\r\nconst initialState = {\r\n  isLoading: false,\r\n  error: false,\r\n  contacts: { byId: {}, allIds: [] },\r\n  conversations: { byId: {}, allIds: [] },\r\n  activeConversationId: null,\r\n  participants: [],\r\n  recipients: []\r\n};\r\n\r\nconst slice = createSlice({\r\n  name: 'privatechat',\r\n  initialState,\r\n  reducers: {\r\n    // START LOADING\r\n    startLoading(state) {\r\n      state.isLoading = true;\r\n    },\r\n\r\n    // HAS ERROR\r\n    hasError(state, action) {\r\n      state.isLoading = false;\r\n      state.error = action.payload;\r\n    },\r\n\r\n    // GET CONTACT SSUCCESS\r\n    getContactsSuccess(state, action) {\r\n      const contacts = action.payload;\r\n      state.contacts.byId = objFromArray(contacts);\r\n      state.contacts.allIds = Object.keys(state.contacts.byId);\r\n    },\r\n\r\n    // GET CONVERSATIONS\r\n    getConversationsSuccess(state, action) {\r\n      const conversations = action.payload;\r\n\r\n      state.conversations.byId = objFromArray(conversations);\r\n      state.conversations.allIds = Object.keys(state.conversations.byId);\r\n    },\r\n\r\n    // GET CONVERSATION\r\n    getConversationSuccess(state, action) {\r\n      const conversation = action.payload;\r\n      if (conversation) {\r\n        state.conversations.byId[conversation._id] = conversation;\r\n        if (!state.conversations.allIds.includes(conversation._id)) {\r\n          state.conversations.allIds.push(conversation._id);\r\n        }\r\n      }\r\n    },\r\n\r\n    // ON SEND MESSAGE\r\n    onSendMessage(state, action) {\r\n      const conversation = action.payload;\r\n      const { conversationId, messageId, message, imgs, senderId, senderName, receiverId, messageType } = conversation;\r\n\r\n      const newMessage = {\r\n        sender_id: senderId,\r\n        sender_name: senderName,\r\n        _id: messageId,\r\n        chat_id: conversationId,\r\n        message,\r\n        receiver_id: receiverId,\r\n        message_type: messageType,\r\n        imgs,\r\n        createdAt: Date.now()\r\n      };\r\n\r\n      state.conversations.byId[conversationId].messages.push(newMessage);\r\n    },\r\n\r\n    markConversationAsReadSuccess(state, action) {\r\n      const { conversationId } = action.payload;\r\n      const conversation = state.conversations.byId[conversationId];\r\n      if (conversation) {\r\n        conversation.lastMessage.unread_count = 0;\r\n      }\r\n    },\r\n\r\n    // GET PARTICIPANTS\r\n    getParticipantsSuccess(state, action) {\r\n      const participants = action.payload;\r\n      state.participants = participants;\r\n    },\r\n\r\n    // RESET ACTIVE CONVERSATION\r\n    resetActiveConversation(state) {\r\n      state.activeConversationId = null;\r\n    },\r\n\r\n    getActiveConversationIdSuccess(state, action) {\r\n      const activeConversationId = action.payload;\r\n      state.activeConversationId = activeConversationId;\r\n    },\r\n\r\n    addRecipients(state, action) {\r\n      const recipients = action.payload;\r\n      state.recipients = recipients;\r\n    }\r\n  }\r\n});\r\n\r\n// Reducer\r\nexport default slice.reducer;\r\n\r\n// Actions\r\nexport const { addRecipients, onSendMessage, resetActiveConversation } = slice.actions;\r\n\r\n// ---------------------------------------------------------------------\r\n// ON SEND MESSAGE\r\nexport function onConnectChat(userOne, userTwo, lastMessage) {\r\n  return async (dispatch) => {\r\n    dispatch(slice.actions.startLoading());\r\n    try {\r\n      const response = await axios.post('/conversions/create', {\r\n        user_one: userOne,\r\n        user_two: userTwo,\r\n        lastMessage\r\n      });\r\n      const responseData = response.data;\r\n      if (responseData.error) {\r\n        dispatch(slice.actions.hasError(response.data));\r\n      } else {\r\n        if (responseData.new) {\r\n          const newMessage = await axios.post('/message/send', {\r\n            messageId: uuidv4(),\r\n            message: lastMessage,\r\n            senderId: userOne,\r\n            receiverId: userTwo,\r\n            chatId: responseData.data._id,\r\n            messageType: 0,\r\n            imgs: []\r\n          });\r\n        }\r\n        dispatch(slice.actions.getActiveConversationIdSuccess(responseData.data._id));\r\n      }\r\n    } catch (error) {\r\n      dispatch(slice.actions.hasError(error));\r\n    }\r\n  };\r\n}\r\n\r\n// ----------------------------------------------------------------------\r\n\r\nexport function getContacts() {\r\n  return async (dispatch) => {\r\n    dispatch(slice.actions.startLoading());\r\n    try {\r\n      const response = await axios.get('/conversions/contacts');\r\n      dispatch(slice.actions.getContactsSuccess(response.data.contacts));\r\n    } catch (error) {\r\n      dispatch(slice.actions.hasError(error));\r\n    }\r\n  };\r\n}\r\n\r\n// ----------------------------------------------------------------------\r\n\r\nexport function getConversations() {\r\n  return async (dispatch) => {\r\n    dispatch(slice.actions.startLoading());\r\n    try {\r\n      const response = await axios.post('/conversions/conversations');\r\n      dispatch(slice.actions.getConversationsSuccess(response.data.conversations));\r\n    } catch (error) {\r\n      dispatch(slice.actions.hasError(error));\r\n    }\r\n  };\r\n}\r\n\r\n// ----------------------------------------------------------------------\r\n\r\nexport function getConversation(chatId) {\r\n  return async (dispatch) => {\r\n    dispatch(slice.actions.startLoading());\r\n    try {\r\n      const response = await axios.post('/conversions/conversation', {\r\n        chat_id: chatId\r\n      });\r\n      dispatch(slice.actions.getConversationSuccess(response.data.conversation));\r\n    } catch (error) {\r\n      dispatch(slice.actions.hasError(error));\r\n    }\r\n  };\r\n}\r\n\r\n// ----------------------------------------------------------------------\r\n\r\nexport function markConversationAsRead(conversationId) {\r\n  return async (dispatch) => {\r\n    dispatch(slice.actions.startLoading());\r\n    try {\r\n      await axios.get('/chat/conversation/mark-as-seen', {\r\n        params: { conversationId }\r\n      });\r\n      dispatch(slice.actions.markConversationAsReadSuccess({ conversationId }));\r\n    } catch (error) {\r\n      dispatch(slice.actions.hasError(error));\r\n    }\r\n  };\r\n}\r\n\r\n// ----------------------------------------------------------------------\r\n\r\nexport function getParticipants(conversationKey) {\r\n  return async (dispatch) => {\r\n    dispatch(slice.actions.startLoading());\r\n    try {\r\n      const response = await axios.get('/chat/participants', {\r\n        params: { conversationKey }\r\n      });\r\n      dispatch(slice.actions.getParticipantsSuccess(response.data.participants));\r\n    } catch (error) {\r\n      dispatch(slice.actions.hasError(error));\r\n    }\r\n  };\r\n}\r\n"]},"metadata":{},"sourceType":"module"}